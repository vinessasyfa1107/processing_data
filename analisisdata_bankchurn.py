# -*- coding: utf-8 -*-
"""AnalisisData_BankChurn

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LUVA55_knbjOMJfs-elllGryTtBxXJed

# **Import Data**
"""

# Mengimpor library pandas dan memberinya alias pd. pandas adalah library yang kuat untuk manipulasi data dan analisis data dalam Python
# Mengimpor library numpy dan memberinya alias np. numpy digunakan untuk operasi numerik dalam Python, terutama yang berhubungan dengan array dan matriks
# Mengimpor modul pyplot dari library matplotlib dan memberinya alias plt. matplotlib digunakan untuk membuat visualisasi data seperti grafik dan plot
# Mengimpor library seaborn dan memberinya alias sns. seaborn adalah library yang dibangun di atas matplotlib dan menyediakan antarmuka tingkat tinggi untuk membuat grafik statistik yang lebih menarik dan informatif
# Mengatur tema default untuk visualisasi seaborn. Ini mengubah tampilan dan nuansa dari semua plot yang dibuat dengan seaborn untuk konsistensi dan keindahan visual yang lebih baik

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme()

# Kode tersebut membaca data dari file CSV, menghapus dua kolom terakhir, mengatur agar semua kolom ditampilkan, dan menampilkan lima baris pertama dari data

cc = pd.read_csv('BankChurners.csv')

# Last two columns not needed
cc = cc.iloc[:, :-2]

pd.set_option('display.max_columns', None)
cc.head()

"""# **Exploring Data**"""

# Perintah cc.describe() digunakan untuk menghasilkan statistik deskriptif dari DataFrame cc

cc.describe()

# Perintah cc.shape digunakan untuk menampilkan dimensi DataFrame cc dalam bentuk tuple (baris, kolom)

cc.shape

# Perintah cc.isnull().sum() digunakan untuk menghitung jumlah nilai yang hilang (missing values) di setiap kolom dalam DataFrame cc

cc.isnull().sum()

"""# **Create Model and Cluster Data**"""

# Baris kode ini mengimpor beberapa modul dan fungsi dari library scikit-learn, kemudian mendefinisikan kolom-kolom yang akan digunakan untuk analisis lebih lanjut

from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler

cols = cc.iloc[:, 9:].select_dtypes(['uint8', 'int64', 'float64']).columns

# Inisialisasi list untuk menyimpan wcss
wcss = []

# Loop untuk menentukan nilai WCSS untuk setiap jumlah cluster
for i in range(2, 16):
    km = KMeans(n_clusters=i, init='k-means++', max_iter=500, n_init=10, random_state=1)
    data = StandardScaler().fit_transform(cc[cols])
    km.fit(data)
    wcss.append(km.inertia_)

# Plot hasil menggunakan Metode Elbow
fig = plt.figure(figsize=(10, 8))
plt.plot(range(2, 16), wcss)
plt.title('Elbow Method')
plt.xlabel('K Clusters')
plt.ylabel('Within-cluster Sums of Squares')
plt.show()

# Kode ini menginisialisasi tiga pipa pemrosesan data untuk analisis klasterisasi. Pipa pertama melakukan penskalaan fitur dan reduksi dimensi menggunakan PCA
# Pipa kedua menerapkan algoritma KMeans untuk klasterisasi data
# Pipa terakhir menggabungkan kedua pipa sebelumnya. Setelah semua pipa didefinisikan, data dari kolom-kolom yang ditentukan dijadikan sebagai input, kemudian model dipelajari dari data tersebut

preprocessor = Pipeline(
    [
        ("scaler", StandardScaler()),
        ("pca", PCA(n_components=2, random_state=1))
    ]
)

clusterer = Pipeline(
    [
        (
            "kmeans",
            KMeans(
                n_clusters=6,
                init="k-means++",
                n_init=50,
                max_iter=1000,
                random_state=1
            )
        )
    ]
)

pipe = Pipeline(
    [
        ("preprocessor", preprocessor),
        ("clusterer", clusterer)
    ]
)

pipe.fit(cc[cols])

# Kode ini mencetak rasio varians yang dijelaskan oleh masing-masing komponen utama (PCA) yang dihasilkan oleh pipa pemrosesan data sebelumnya
# Ini memberikan informasi tentang seberapa banyak variasi dalam data yang dijelaskan oleh setiap komponen utama

print('PCA Component 1 Ratio of Explained Variance')
print(round(preprocessor['pca'].explained_variance_ratio_[0],2))
print()
print('PCA Component 2 Ratio of Explained Variance')
print(round(preprocessor['pca'].explained_variance_ratio_[1],2))

preprocessed_data = pipe["preprocessor"].transform(cc[cols])
predicted_labels = pipe["clusterer"]["kmeans"].labels_
print('Silhoutte Score :', round(silhouette_score(preprocessed_data,  predicted_labels),3))

# Kode ini menghasilkan prediksi label klaster untuk data yang telah diproses melalui pipa pemrosesan data sebelumnya
# Kemudian, menggunakan metrik silhouette score, ia mengukur seberapa baik pembagian klaster tersebut dengan mengukur
# seberapa dekat setiap titik data dalam suatu klaster dengan titik-titik dalam klaster yang sama dibandingkan dengan klaster lainnya
# Hasilnya dicetak sebagai silhouette score yang dibulatkan ke tiga angka desimal

# Transformasi data menggunakan preprocessor dan membuat DataFrame baru
pcadf = pd.DataFrame(
    pipe["preprocessor"].transform(cc[cols]),
    columns=["component_1", "component_2"]
)

# Menambahkan kolom untuk cluster yang diprediksi
pcadf["predicted_cluster"] = pipe["clusterer"]["kmeans"].labels_

# Mengatur style plot
plt.style.use("fivethirtyeight")
plt.figure(figsize=(8, 8))

# Membuat scatter plot menggunakan seaborn
sp = sns.scatterplot(
    x="component_1",
    y="component_2",
    s=50,
    data=pcadf,
    hue="predicted_cluster",
    palette='tab10'
)

# Menambahkan judul pada plot
sp.set_title("Clustering results from credit card use")

# Mengatur legend pada plot
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)
plt.show()

cc['cluster'] = pipe['clusterer']['kmeans'].labels_
cc.head()

# Kode ini menambahkan kolom baru ke DataFrame cc yang berisi label klaster yang diprediksi untuk setiap data menggunakan model klaster yang telah dilatih sebelumnya
# Setiap baris dari DataFrame sekarang memiliki label klaster yang sesuai
# Kemudian, lima baris pertama dari DataFrame yang telah dimodifikasi tersebut dicetak

# Kode ini menghasilkan sebuah diagram lingkaran yang menampilkan komposisi klaster dari data
# Setiap klaster direpresentasikan sebagai bagian dari lingkaran dengan proporsi yang sesuai dengan jumlah data yang terkait dengan klaster tersebut
# Persentase setiap klaster dicetak di sekitar lingkaran

fig, axs=plt.subplots(figsize=(12,8))
ax=cc['cluster'].value_counts().plot.pie(title='Cluster Composition', autopct='%1.0f%%')
plt.title=False
ax.set_ylabel('')
plt.show()

# Kode ini menghasilkan subplot yang terdiri dari 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan grafik batang yang menunjukkan jumlah data dalam setiap kategori Attrition_Flag (mungkin Existing Customer dan Attrited Customer)
# untuk setiap klaster yang diprediksi. Subplot-subplot tersebut diberi judul sesuai dengan kelompok klaster yang sesuai

fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(18,14))

cc[cc['cluster'] == 0]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[0,0], title='Group 1')
cc[cc['cluster'] == 1]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[0,1], title='Group 2')
cc[cc['cluster'] == 2]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[1,0], title='Group 3')
cc[cc['cluster'] == 3]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[1,1], title='Group 4')
cc[cc['cluster'] == 4]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[2,0], title='Group 5')
cc[cc['cluster'] == 5]['Attrition_Flag'].value_counts().sort_index().plot.barh(ax=axs[2,1], title='Group 6')

# Kode ini menerapkan penskalaan standar ke data pada kolom yang telah dipilih dari DataFrame cc
# Kolom tambahan 'cluster' ditambahkan ke DataFrame yang berisi label klaster yang diprediksi menggunakan model klaster yang sudah ada sebelumnya

scaler = StandardScaler()
scaled_cc = pd.DataFrame(scaler.fit_transform(cc[cols]), columns=cols)
scaled_cc['cluster'] = pipe['clusterer']['kmeans'].labels_
scaled_cc.head()

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan grafik batang horizontal yang menunjukkan rata-rata nilai dari setiap fitur (kolom) untuk setiap klaster yang diprediksi

fix, axs = plt.subplots(ncols=2,nrows=3, figsize=(20,32))

scaled_cc[scaled_cc['cluster'] == 0][cols].mean().plot.barh(ax=axs[0,0], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group1')
scaled_cc[scaled_cc['cluster'] == 1][cols].mean().plot.barh(ax=axs[0,1], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group2')
scaled_cc[scaled_cc['cluster'] == 2][cols].mean().plot.barh(ax=axs[1,0], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group3')
scaled_cc[scaled_cc['cluster'] == 3][cols].mean().plot.barh(ax=axs[1,1], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group4')
scaled_cc[scaled_cc['cluster'] == 4][cols].mean().plot.barh(ax=axs[2,0], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group5')
scaled_cc[scaled_cc['cluster'] == 5][cols].mean().plot.barh(ax=axs[2,1], xlim=(-1.5, 3), figsize=(20,20), sharey=True, title='Group6')

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan histogram distribusi umur pelanggan untuk setiap klaster yang diprediksi. Rentang bin histogram diatur antara 20 dan 70 dengan lebar bin sebesar 5

fig, axs = plt.subplots(ncols=2, nrows=3, figsize=(12, 14))

sns.histplot(cc[cc['cluster'] == 0]['Customer_Age'], ax=axs[0, 0], binrange=(20, 70), binwidth=5).set(title='High balance heavy users')
sns.histplot(cc[cc['cluster'] == 1]['Customer_Age'], ax=axs[0, 1], binrange=(20, 70), binwidth=5).set(title='Long time very light users')
sns.histplot(cc[cc['cluster'] == 2]['Customer_Age'], ax=axs[1, 0], binrange=(20, 70), binwidth=5).set(title='Low limit, high balance light users')
sns.histplot(cc[cc['cluster'] == 3]['Customer_Age'], ax=axs[1, 1], binrange=(20, 70), binwidth=5).set(title='High limit, low balance light users')
sns.histplot(cc[cc['cluster'] == 4]['Customer_Age'], ax=axs[2, 0], binrange=(20, 70), binwidth=5).set(title='Low limit, low balance light users')
sns.histplot(cc[cc['cluster'] == 5]['Customer_Age'], ax=axs[2, 1], binrange=(20, 70), binwidth=5).set(title='High limit, low balance heavy users')

plt.tight_layout()
plt.show()

# Membuat pie chart
# Kode ini membuat sebuah diagram lingkaran (pie chart) yang menunjukkan distribusi jumlah pelanggan dalam setiap klaster yang diprediksi
# Setiap klaster direpresentasikan sebagai bagian dari lingkaran dengan proporsi yang sesuai dengan jumlah pelanggan di dalamnya


cluster_counts = cc['cluster'].value_counts().sort_index()
labels = [
    'High balance heavy users',
    'Long time very light users',
    'Low limit, high balance light users',
    'High limit, low balance light users',
    'Low limit, low balance light users',
    'High limit, low balance heavy users'
]

fig, ax = plt.subplots(figsize=(10, 8))
ax.pie(cluster_counts, labels=labels, autopct='%1.1f%%', startangle=140, colors=sns.color_palette('tab10'))

ax.set_title('Distribution of Customers by Cluster')
plt.show()

fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(12,14))

cc[cc['cluster'] == 0]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[0,0], title='Higher balance heavy users')
cc[cc['cluster'] == 1]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[0,1], title='Long time very light users')
cc[cc['cluster'] == 2]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[1,0], title='Low limit, high balance light users')
cc[cc['cluster'] == 3]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[1,1], title='High limit, low balance light users')
cc[cc['cluster'] == 4]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[2,0], title='Low limit, low balance light users')
cc[cc['cluster'] == 5]['Dependent_count'].value_counts().sort_index().plot.bar(ax=axs[2,1], title='High limit, low balance heavy users')

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
#Setiap subplot menampilkan grafik batang yang menunjukkan jumlah pelanggan dalam setiap kategori jumlah tanggungan (Dependent_count) untuk setiap klaster yang diprediksi


fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(12,14))

cc[cc['cluster'] == 0]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[0,0], ylabel='', title='Higher balance heavy users')
cc[cc['cluster'] == 1]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[0,1], ylabel='', title='Long time very light users')
cc[cc['cluster'] == 2]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[1,0], ylabel='', title='Low limit, high balance light users')
cc[cc['cluster'] == 3]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[1,1], ylabel='', title='High limit, low balance light users')
cc[cc['cluster'] == 4]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[2,0], ylabel='', title='Low limit, low balance light users')
cc[cc['cluster'] == 5]['Education_Level'].value_counts().sort_index().plot.pie(ax=axs[2,1], ylabel='', title='High limit, low balance heavy users')

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan diagram lingkaran (pie chart) yang menunjukkan distribusi status perkawinan (Marital_Status) untuk setiap klaster yang diprediksi

fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(12,14))

cc[cc['cluster'] == 0]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[0,0], ylabel='', title='Higher balance heavy users')
cc[cc['cluster'] == 1]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[0,1], ylabel='', title='Long time very light users')
cc[cc['cluster'] == 2]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[1,0], ylabel='', title='Low limit, high balance light users')
cc[cc['cluster'] == 3]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[1,1], ylabel='', title='High limit, low balance light users')
cc[cc['cluster'] == 4]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[2,0], ylabel='', title='Low limit, low balance light users')
cc[cc['cluster'] == 5]['Marital_Status'].value_counts().sort_index().plot(kind='pie', ax=axs[2,1], ylabel='', title='High limit, low balance heavy users')

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan diagram lingkaran (pie chart) yang menunjukkan distribusi kategori pendapatan (Income_Category) untuk setiap klaster yang diprediksi

fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(12,14))

cc[cc['cluster'] == 0]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[0,0], ylabel='', title='Higher balance heavy users')
cc[cc['cluster'] == 1]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[0,1], ylabel='', title='Long-time very light users')
cc[cc['cluster'] == 2]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[1,0], ylabel='', title='Low limit, high balance light users')
cc[cc['cluster'] == 3]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[1,1], ylabel='', title='High limit, low balance light users')
cc[cc['cluster'] == 4]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[2,0], ylabel='', title='Low limit, low balance light users')
cc[cc['cluster'] == 5]['Income_Category'].value_counts().sort_index().plot(kind='pie', ax=axs[2,1], ylabel='', title='High limit, low balance heavy users')

# Kode ini menghasilkan subplot dengan 6 bagian, dengan 2 kolom dan 3 baris, dalam sebuah gambar dengan ukuran tertentu
# Setiap subplot menampilkan grafik batang horizontal yang menunjukkan jumlah pelanggan dalam setiap kategori kartu (Card_Category) untuk setiap klaster yang diprediksi.

fig, axs = plt.subplots(ncols=2,nrows=3, figsize=(18,14))

cc[cc['cluster'] == 0]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[0,0], title='Higher balance heavy users')
cc[cc['cluster'] == 1]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[0,1], title='Long-time very light users')
cc[cc['cluster'] == 2]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[1,0], title='Low limit, high balance light users')
cc[cc['cluster'] == 3]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[1,1], title='High limit, low balance light users')
cc[cc['cluster'] == 4]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[2,0], title='Low limit, low balance light users')
cc[cc['cluster'] == 5]['Card_Category'].value_counts().sort_index().plot.barh(ax=axs[2,1], title='High limit, low balance heavy users')

"""# **Knowledge dan Kesimpulan**

Dari hasil analisis di atas, terdapat strategi dan rekomendasi yang bisa dilakukan terhadap
 setiap kelompok pengguna kartu kredit, diantaranya adalah sebagai berikut.

 1. Pengguna dengan saldo tinggi
 ● Tawarkan imbalan dan manfaat yang disesuaikan dengan kebiasaan dan preferensi
 pengeluaran mereka.
 ● Berikan penawaran personal yang dapat meningkatkan penggunaan kartu dan
 saldo mereka.
 ● Pertimbangkan untuk menyediakan opsi transfer saldo dengan suku bunga rendah
 untuk mendorong mereka menggabungkan utang-utang mereka.

 2. Pengguna dengan penggunaan kartu yang sangat rendah namun telah
 lama menjadi pengguna
● Terapkan strategi untuk meningkatkan keterlibatan dan penggunaan kartu pada
 kelompok ini.
 ● Tawarkan insentif seperti pengembalian uang tunai atau diskon khusus untuk
 mendorong penggunaan kartu mereka.

 3. Pengguna dengan batas kredit rendah namun saldo tinggi
 ● Berikan penawaran atau promosi khusus untuk membantu pengguna mengelola
 saldo mereka dan mengurangi utang.
 ● Ajukan peningkatan batas kredit bagi mereka yang memiliki rekam jejak
 penggunaan kartu yang baik.

 4. Pengguna dengan batas kredit tinggi namun saldo rendah
 ● Tawarkan program hadiah atau manfaat eksklusif yang menarik bagi kelompok ini
 untuk mendorong penggunaan kartu mereka.
 ● Berikan layanan pelanggan yang unggul untuk mempertahankan kepuasan mereka
 sebagai pengguna dengan batas kredit tinggi.
 5. Pengguna dengan batas kredit rendah dan saldo rendah
 ● Tawarkan program penghargaan atau diskon yang relevan dengan kebutuhan dan
 preferensi pengguna.
 ● Berikan pendidikan keuangan atau saran untuk membantu mereka meningkatkan
 manajemen keuangan mereka dan memperbaiki profil kredit.
 6. Pengguna dengan batas kredit tinggi namun saldo rendah
 ● Berikan penawaran khusus seperti penawaran bunga rendah atau promosi untuk
 mendorong penggunaan lebih lanjut dari kartu mereka.
 ● Tawarkan insentif tambahan yang relevan dengan gaya hidup dan preferensi
 mereka untuk mendorong penggunaan kartu yang lebih aktif.
 Selain itu, penting juga untuk melakukan survei atau penelitian lebih lanjut guna
 memahami kebutuhan, preferensi, dan masalah yang spesifik dalam setiap kelompok
 pengguna. Hal ini akan membantu dalam mengembangkan strategi yang lebih efektif dan terarah.

 Berdasarkan hasil pembahasan tersebut, maka dapat disimpulkan bahwa data
 mining menjadi salah satu teknik yang digunakan dalam mengolah data yang efektif
 untuk menghasilkan pengetahuan yang berguna dalam pengambilan keputusan. Hasil
 analisis model kami, berdasarkan sepuluh analisis diantaranya tentang komposisi kluster,
 turnover, aktivitas akun, umur, gender, jumlah tanggungan, tingkat pendidikan, status
 pernikahan, tingkat pendapatan, dantipe kartu bahwa pengguna kartu kredit dapat
 dikelompokkan ke dalam enam kelompok dengan karakteristik yang berbeda. Pengguna
 dengan saldo tinggi, pengguna dengan penggunaan kartu yang sangat rendah namun telah
 lama menjadi pengguna, dan pengguna dengan batas kredit rendah namun saldo tinggi
 adalah kelompok yang perlu mendapatkan perhatian khusus.
 Rekomendasi strategis termasuk memberikan insentif dan manfaat yang
 disesuaikan dengan kebutuhan dan kebiasaan pengguna, meningkatkan keterlibatan dan
 penggunaan kartu, serta memberikan program pengelolaan saldo dan pendidikan
 keuangan. Di sisi lain, pengguna dengan batas kredit tinggi namun saldo rendah dan
 pengguna dengan batas kredit rendah dan saldo rendah membutuhkan penawaran khusus,
 insentif tambahan, dan program penghargaan yang relevan untuk mendorong penggunaan
 aktif kartu kredit. Penting untuk melakukan survei lebih lanjut guna memahami
 kebutuhan dan masalah spesifik dalam setiap kelompok pengguna agar dapat
 mengembangkan strategi yang lebih efektif dan sesuai

"""